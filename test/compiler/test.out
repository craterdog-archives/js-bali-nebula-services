Running "clean:build" (clean) task
>> 2 paths cleaned.

Running "jshint:files" (jshint) task
>> 43 files lint free.

Running "nodeunit:tests" (nodeunit) task
Testing TestBaliCompiler.js
test/compiler/main.basm:

1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/mainWithFinal.basm:

1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/mainWithExceptions.basm:

1.ThrowClause:
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'whine'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE VARIABLE $_exception_
JUMP TO 2.BlockEnd

1.HandleClauses:
LOAD VARIABLE $_exception_
JUMP TO 1.StatementEnd ON NONE
LOAD VARIABLE $_exception_

1.1.HandleClause:
STORE VARIABLE $error
LOAD VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'bad'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.1.ClauseEnd ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.1.ClauseEnd:
LOAD VARIABLE $_exception_
JUMP TO 1.StatementEnd ON NONE
LOAD VARIABLE $_exception_

1.2.HandleClause:
STORE VARIABLE $error
LOAD VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'horrid'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.2.ClauseEnd ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.2.ClauseEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/mainWithExceptionsAndFinal.basm:

1.ThrowClause:
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'whine'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE VARIABLE $_exception_
JUMP TO 2.BlockEnd

1.HandleClauses:
LOAD VARIABLE $_exception_
JUMP TO 1.FinishClause ON NONE
LOAD VARIABLE $_exception_

1.1.HandleClause:
STORE VARIABLE $error
LOAD VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'bad'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.1.ClauseEnd ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.1.ClauseEnd:
LOAD VARIABLE $_exception_
JUMP TO 1.FinishClause ON NONE
LOAD VARIABLE $_exception_

1.2.HandleClause:
STORE VARIABLE $error
LOAD VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `'horrid'`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.2.ClauseEnd ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.2.ClauseEnd:
SKIP INSTRUCTION

1.FinishClause:
SKIP INSTRUCTION

1.3.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.3.2.BlockEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/evaluateExpression.basm:

1.EvaluateClause:
LOAD LITERAL `2`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$foo`
LOAD VARIABLE $bar
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$baz`
LOAD LITERAL `5`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE VARIABLE $_result_

2.EvaluateClause:
LOAD VARIABLE $variable
STORE VARIABLE $_result_

3.EvaluateClause:
LOAD LITERAL `<bali:/bali/types/SomeType>`
LOAD LITERAL `1`
INVOKE INTRINSIC $array WITH PARAMETER
LOAD LITERAL `13`
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
EXECUTE PROCEDURE $isPrime WITH PARAMETERS
STORE VARIABLE $_result_

4.EvaluateClause:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC $sum WITH 2 PARAMETERS
LOAD VARIABLE $c
INVOKE INTRINSIC $product WITH 2 PARAMETERS
STORE VARIABLE $_result_

5.EvaluateClause:
LOAD VARIABLE $reference
STORE VARIABLE $_location_1
LOAD DOCUMENT $_location_1
STORE VARIABLE $_result_

6.EvaluateClause:
LOAD VARIABLE $customer
LOAD LITERAL `$order`
INVOKE INTRINSIC $getValue WITH 2 PARAMETERS
LOAD LITERAL `$item`
INVOKE INTRINSIC $getValue WITH 2 PARAMETERS
LOAD LITERAL `5`
INVOKE INTRINSIC $getValue WITH 2 PARAMETERS
STORE VARIABLE $_result_

7.EvaluateClause:
LOAD VARIABLE $list
LOAD LITERAL `1`
INVOKE INTRINSIC $array WITH PARAMETER
LOAD VARIABLE $item
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
EXECUTE PROCEDURE $addItem ON TARGET WITH PARAMETERS
STORE VARIABLE $_result_

8.EvaluateClause:
LOAD LITERAL `23`
INVOKE INTRINSIC $factorial WITH PARAMETER
STORE VARIABLE $_result_

9.EvaluateClause:
LOAD LITERAL `2`
LOAD LITERAL `8`
INVOKE INTRINSIC $exponential WITH 2 PARAMETERS
STORE VARIABLE $_result_

10.EvaluateClause:
LOAD LITERAL `-pi`
STORE VARIABLE $_result_

11.EvaluateClause:
LOAD LITERAL `5`
INVOKE INTRINSIC $inverse WITH PARAMETER
STORE VARIABLE $_result_

12.EvaluateClause:
LOAD LITERAL `(3, 4i)`
INVOKE INTRINSIC $conjugate WITH PARAMETER
STORE VARIABLE $_result_

13.EvaluateClause:
LOAD VARIABLE $x
LOAD VARIABLE $y
INVOKE INTRINSIC $product WITH 2 PARAMETERS
STORE VARIABLE $_result_

14.EvaluateClause:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC $quotient WITH 2 PARAMETERS
STORE VARIABLE $_result_

15.EvaluateClause:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC $remainder WITH 2 PARAMETERS
STORE VARIABLE $_result_

16.EvaluateClause:
LOAD VARIABLE $x
LOAD VARIABLE $y
INVOKE INTRINSIC $sum WITH 2 PARAMETERS
STORE VARIABLE $_result_

17.EvaluateClause:
LOAD VARIABLE $w
LOAD VARIABLE $z
INVOKE INTRINSIC $difference WITH 2 PARAMETERS
STORE VARIABLE $_result_

18.EvaluateClause:
LOAD LITERAL `(3, 4i)`
INVOKE INTRINSIC $magnitude WITH PARAMETER
STORE VARIABLE $_result_

19.EvaluateClause:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC $less WITH 2 PARAMETERS
STORE VARIABLE $_result_

20.EvaluateClause:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC $equal WITH 2 PARAMETERS
STORE VARIABLE $_result_

21.EvaluateClause:
LOAD VARIABLE $f
LOAD VARIABLE $g
INVOKE INTRINSIC $more WITH 2 PARAMETERS
STORE VARIABLE $_result_

22.EvaluateClause:
LOAD VARIABLE $h
LOAD VARIABLE $j
INVOKE INTRINSIC $is WITH 2 PARAMETERS
STORE VARIABLE $_result_

23.EvaluateClause:
LOAD VARIABLE $k
LOAD VARIABLE $m
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
STORE VARIABLE $_result_

24.EvaluateClause:
LOAD VARIABLE $p
INVOKE INTRINSIC $complement WITH PARAMETER
STORE VARIABLE $_result_

25.EvaluateClause:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC $and WITH 2 PARAMETERS
STORE VARIABLE $_result_

26.EvaluateClause:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC $sans WITH 2 PARAMETERS
STORE VARIABLE $_result_

27.EvaluateClause:
LOAD VARIABLE $f
LOAD VARIABLE $g
INVOKE INTRINSIC $xor WITH 2 PARAMETERS
STORE VARIABLE $_result_

28.EvaluateClause:
LOAD VARIABLE $h
LOAD VARIABLE $j
INVOKE INTRINSIC $or WITH 2 PARAMETERS
STORE VARIABLE $_result_

29.EvaluateClause:
LOAD VARIABLE $foo
LOAD LITERAL `5`
INVOKE INTRINSIC $default WITH 2 PARAMETERS
STORE VARIABLE $_result_

30.BlockEnd:
SKIP INSTRUCTION



test/compiler/evaluateExpressionWithResult.basm:

1.EvaluateClause:
LOAD VARIABLE $bar
STORE VARIABLE $foo

2.EvaluateClause:
LOAD VARIABLE $document
LOAD LITERAL `$customer`
INVOKE INTRINSIC $getValue WITH 2 PARAMETERS
LOAD LITERAL `$order`
INVOKE INTRINSIC $getValue WITH 2 PARAMETERS
LOAD LITERAL `3`
LOAD LITERAL `5`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS

3.BlockEnd:
SKIP INSTRUCTION



test/compiler/ifThen.basm:

1.IfClause:
SKIP INSTRUCTION

1.1.ConditionBlock:
LOAD LITERAL `true`
JUMP TO 1.StatementEnd ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/ifThenElse.basm:

1.IfClause:
SKIP INSTRUCTION

1.1.ConditionBlock:
LOAD LITERAL `true`
JUMP TO 1.2.ElseBlock ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
JUMP TO 1.StatementEnd

1.2.ElseBlock:
SKIP INSTRUCTION

1.2.1.EvaluateClause:
LOAD LITERAL `false`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/ifThenElseIf.basm:

1.IfClause:
SKIP INSTRUCTION

1.1.ConditionBlock:
LOAD LITERAL `true`
JUMP TO 1.2.ConditionBlock ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
JUMP TO 1.StatementEnd

1.2.ConditionBlock:
LOAD LITERAL `false`
JUMP TO 1.StatementEnd ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `false`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/ifThenElseIfElse.basm:

1.IfClause:
SKIP INSTRUCTION

1.1.ConditionBlock:
LOAD LITERAL `true`
JUMP TO 1.2.ConditionBlock ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
JUMP TO 1.StatementEnd

1.2.ConditionBlock:
LOAD LITERAL `false`
JUMP TO 1.3.ElseBlock ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `false`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
JUMP TO 1.StatementEnd

1.3.ElseBlock:
SKIP INSTRUCTION

1.3.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.3.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/selectOption.basm:

1.SelectClause:
LOAD LITERAL `$selection`
STORE VARIABLE $_selector_1

1.1.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'alpha'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.2.OptionBlock ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
JUMP TO 1.StatementEnd

1.2.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'beta'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.3.OptionBlock ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
JUMP TO 1.StatementEnd

1.3.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'gamma'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE

1.3.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.3.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/selectOptionElse.basm:

1.SelectClause:
LOAD LITERAL `$selection`
STORE VARIABLE $_selector_1

1.1.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'alpha'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.2.OptionBlock ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.2.BlockEnd:
JUMP TO 1.StatementEnd

1.2.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'beta'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.3.OptionBlock ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.2.2.BlockEnd:
JUMP TO 1.StatementEnd

1.3.OptionBlock:
LOAD VARIABLE $_selector_1
LOAD LITERAL `'gamma'`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.4.ElseBlock ON FALSE

1.3.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.3.2.BlockEnd:
JUMP TO 1.StatementEnd

1.4.ElseBlock:
SKIP INSTRUCTION

1.4.1.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.4.2.BlockEnd:
SKIP INSTRUCTION

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/whileLoop.basm:

1.WhileClause:
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WhileCondition

1.1.1.1.WhileCondition:
LOAD VARIABLE $_continue_1_1_WhileCondition
LOAD VARIABLE $condition
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BreakClause:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_WhileCondition
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.WhileCondition

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/whileLoopWithLabel.basm:

1.WhileClause:
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD VARIABLE $condition
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.ContinueClause:
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.Label

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/withLoop.basm:

1.WithClause:
LOAD LITERAL `$sequence`
INVOKE INTRINSIC $createIterator WITH PARAMETER
STORE VARIABLE $_iterator_2
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WithItem

1.1.1.1.WithItem:
LOAD VARIABLE $_continue_1_1_WithItem
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $hasNext WITH PARAMETER
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $getNext WITH PARAMETER
STORE VARIABLE $_item_1

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.ContinueClause:
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.WithItem

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/withLoopWithLabel.basm:

1.WithClause:
LOAD LITERAL `$sequence`
INVOKE INTRINSIC $createIterator WITH PARAMETER
STORE VARIABLE $_iterator_2
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $hasNext WITH PARAMETER
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $getNext WITH PARAMETER
STORE VARIABLE $_item_1

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BreakClause:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_Label
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.Label

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/withEachLoop.basm:

1.WithClause:
LOAD LITERAL `$sequence`
INVOKE INTRINSIC $createIterator WITH PARAMETER
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WithItem

1.1.1.1.WithItem:
LOAD VARIABLE $_continue_1_1_WithItem
LOAD VARIABLE $_iterator_1
INVOKE INTRINSIC $hasNext WITH PARAMETER
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE
LOAD VARIABLE $_iterator_1
INVOKE INTRINSIC $getNext WITH PARAMETER
STORE VARIABLE $symbol

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.ContinueClause:
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.WithItem

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/withEachLoopWithLabel.basm:

1.WithClause:
LOAD LITERAL `$sequence`
INVOKE INTRINSIC $createIterator WITH PARAMETER
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD VARIABLE $_iterator_1
INVOKE INTRINSIC $hasNext WITH PARAMETER
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 1.StatementEnd ON FALSE
LOAD VARIABLE $_iterator_1
INVOKE INTRINSIC $getNext WITH PARAMETER
STORE VARIABLE $symbol

1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

1.1.2.BreakClause:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_Label
JUMP TO 1.1.4.BlockEnd

1.1.3.EvaluateClause:
LOAD LITERAL `none`
STORE VARIABLE $_result_

1.1.4.BlockEnd:
JUMP TO 1.1.Label

1.StatementEnd:
SKIP INSTRUCTION

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/queueMessage.basm:

1.QueueClause:
LOAD LITERAL `<bali:/#MJ0YKAX450LD84TCFJ7CNJ5CX8ZAPZ1Qv3.1>`
STORE VARIABLE $_queue_1
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$foo`
LOAD VARIABLE $bar
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE MESSAGE $_queue_1

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/waitForMessage.basm:

1.WaitClause:
LOAD LITERAL `<bali:/#MJ0YKAX450LD84TCFJ7CNJ5CX8ZAPZ1Qv3.1>`
STORE VARIABLE $_queue_1
LOAD MESSAGE $_queue_1
STORE VARIABLE $message

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/publishEvent.basm:

1.PublishClause:
LOAD LITERAL `3`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `$changeEvent`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$key`
LOAD LITERAL `$foo`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$value`
LOAD LITERAL `5`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE MESSAGE $_eventQueue_

2.BlockEnd:
SKIP INSTRUCTION



test/compiler/comprehensive.basm:

1.IfClause:
SKIP INSTRUCTION

1.1.ConditionBlock:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC $less WITH 2 PARAMETERS
JUMP TO 1.2.ConditionBlock ON FALSE

1.1.1.EvaluateClause:
LOAD VARIABLE $b
STORE VARIABLE $a

1.1.2.EvaluateClause:
LOAD VARIABLE $c
STORE VARIABLE $b

1.1.3.ThrowClause:
LOAD VARIABLE $exception
STORE VARIABLE $_exception_
JUMP TO 1.1.4.BlockEnd

1.1.4.BlockEnd:
JUMP TO 1.FinishClause

1.2.ConditionBlock:
LOAD VARIABLE $a
LOAD LITERAL `0`
INVOKE INTRINSIC $more WITH 2 PARAMETERS
JUMP TO 1.3.ElseBlock ON FALSE

1.2.1.EvaluateClause:
LOAD LITERAL `false`
STORE VARIABLE $_result_

1.2.2.EvaluateClause:
LOAD LITERAL `<bali:/bali/types/SomeType>`
LOAD LITERAL `1`
INVOKE INTRINSIC $array WITH PARAMETER
LOAD VARIABLE $b
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
EXECUTE PROCEDURE $fibonacci WITH PARAMETERS
STORE VARIABLE $c

1.2.3.ReturnClause:
LOAD VARIABLE $c
STORE VARIABLE $_result_
JUMP TO 1.2.4.BlockEnd

1.2.4.BlockEnd:
JUMP TO 1.FinishClause

1.3.ElseBlock:
SKIP INSTRUCTION

1.3.1.EvaluateClause:
LOAD VARIABLE $b
LOAD LITERAL `1`
INVOKE INTRINSIC $array WITH PARAMETER
LOAD LITERAL `$tag`
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
EXECUTE PROCEDURE $find ON TARGET WITH PARAMETERS
STORE VARIABLE $d

1.3.2.EvaluateClause:
LOAD LITERAL `(3, 4i)`
STORE VARIABLE $_result_

1.3.3.ReturnClause:
JUMP TO 1.3.4.BlockEnd

1.3.4.BlockEnd:
SKIP INSTRUCTION

1.HandleClauses:
LOAD VARIABLE $_exception_
JUMP TO 1.FinishClause ON NONE
LOAD VARIABLE $_exception_

1.4.HandleClause:
STORE VARIABLE $exception
LOAD VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `$warning`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.4.ClauseEnd ON FALSE

1.4.1.EvaluateClause:
LOAD VARIABLE $count
LOAD LITERAL `1`
INVOKE INTRINSIC $sum WITH 2 PARAMETERS
STORE VARIABLE $count

1.4.2.EvaluateClause:
LOAD LITERAL `2`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$message`
LOAD LITERAL `"Something not too serious happened."`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE VARIABLE $_result_

1.4.3.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.4.ClauseEnd:
LOAD VARIABLE $_exception_
JUMP TO 1.FinishClause ON NONE
LOAD VARIABLE $_exception_

1.5.HandleClause:
STORE VARIABLE $exception
LOAD VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `$moderate`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 1.5.ClauseEnd ON FALSE

1.5.1.EvaluateClause:
LOAD LITERAL `2`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$message`
LOAD LITERAL `"Something serious happened."`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE VARIABLE $exception

1.5.2.ThrowClause:
LOAD VARIABLE $exception
STORE VARIABLE $_exception_
JUMP TO 1.5.3.BlockEnd

1.5.3.BlockEnd:
LOAD LITERAL `none`
STORE VARIABLE $_exception_

1.5.ClauseEnd:
SKIP INSTRUCTION

1.FinishClause:
SKIP INSTRUCTION

1.6.1.QueueClause:
LOAD LITERAL `<bali:/#RSTMWSC0HFY00QJP37QD3JA533NLKPP5v3.1>`
STORE VARIABLE $_queue_1
LOAD LITERAL `4`
INVOKE INTRINSIC $array WITH PARAMETER
LOAD VARIABLE $foo
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
LOAD VARIABLE $bar
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
LOAD VARIABLE $baz
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
LOAD LITERAL `5`
INVOKE INTRINSIC $addItem WITH 2 PARAMETERS
STORE MESSAGE $_queue_1

1.6.2.PublishClause:
LOAD LITERAL `2`
INVOKE INTRINSIC $table WITH PARAMETER
LOAD LITERAL `$type`
LOAD LITERAL `$confirmation`
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
LOAD LITERAL `$timestamp`
LOAD LITERAL `<bali:/bali/types/SomeType>`
EXECUTE PROCEDURE $now
INVOKE INTRINSIC $setValue WITH 3 PARAMETERS
STORE MESSAGE $_eventQueue_

1.6.3.BlockEnd:
SKIP INSTRUCTION

2.WhileClause:
LOAD LITERAL `true`
STORE VARIABLE $_continue_2_1_Outer

2.1.2.1.Outer:
LOAD VARIABLE $_continue_2_1_Outer
LOAD LITERAL `true`
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 2.FinishClause ON FALSE

2.1.1.EvaluateClause:
LOAD VARIABLE $bar
STORE VARIABLE $foo

2.1.2.IfClause:
SKIP INSTRUCTION

2.1.2.1.ConditionBlock:
LOAD VARIABLE $foo
JUMP TO 2.1.2.2.ElseBlock ON FALSE

2.1.2.1.1.BreakClause:
LOAD LITERAL `false`
STORE VARIABLE $_continue_2_1_Outer
JUMP TO 2.1.2.1.2.BlockEnd

2.1.2.1.2.BlockEnd:
JUMP TO 2.1.2.FinishClause

2.1.2.2.ElseBlock:
SKIP INSTRUCTION

2.1.2.2.1.WithClause:
LOAD VARIABLE $sequence
INVOKE INTRINSIC $createIterator WITH PARAMETER
STORE VARIABLE $_iterator_2
LOAD LITERAL `true`
STORE VARIABLE $_continue_2_1_2_2_1_1_WithItem

2.1.2.2.1.1.2.1.2.2.1.1.WithItem:
LOAD VARIABLE $_continue_2_1_2_2_1_1_WithItem
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $hasNext WITH PARAMETER
INVOKE INTRINSIC $and WITH 2 PARAMETERS
JUMP TO 2.1.2.2.1.FinishClause ON FALSE
LOAD VARIABLE $_iterator_2
INVOKE INTRINSIC $getNext WITH PARAMETER
STORE VARIABLE $item

2.1.2.2.1.1.1.SelectClause:
LOAD VARIABLE $selection
STORE VARIABLE $_selector_3

2.1.2.2.1.1.1.1.OptionBlock:
LOAD VARIABLE $_selector_3
LOAD LITERAL `$first`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 2.1.2.2.1.1.1.2.OptionBlock ON FALSE

2.1.2.2.1.1.1.1.1.EvaluateClause:
LOAD LITERAL `true`
STORE VARIABLE $_result_

2.1.2.2.1.1.1.1.2.BlockEnd:
JUMP TO 2.1.2.2.1.1.1.FinishClause

2.1.2.2.1.1.1.2.OptionBlock:
LOAD VARIABLE $_selector_3
LOAD LITERAL `$second`
INVOKE INTRINSIC $matches WITH 2 PARAMETERS
JUMP TO 2.1.2.2.1.1.1.3.ElseBlock ON FALSE

2.1.2.2.1.1.1.2.1.EvaluateClause:
LOAD LITERAL `false`
STORE VARIABLE $_result_

2.1.2.2.1.1.1.2.2.BlockEnd:
JUMP TO 2.1.2.2.1.1.1.FinishClause

2.1.2.2.1.1.1.3.ElseBlock:
SKIP INSTRUCTION

2.1.2.2.1.1.1.3.1.ContinueClause:
LOAD LITERAL `false`
STORE VARIABLE $_continue_2_1_2_2_1_1_WithItem
JUMP TO 2.1.2.2.1.1.1.3.2.BlockEnd

2.1.2.2.1.1.1.3.2.BlockEnd:
SKIP INSTRUCTION

2.1.2.2.1.1.1.FinishClause:
SKIP INSTRUCTION

2.1.2.2.1.1.1.4.1.EvaluateClause:
LOAD LITERAL `$selectDone`
STORE VARIABLE $_result_

2.1.2.2.1.1.1.4.2.BlockEnd:
SKIP INSTRUCTION

2.1.2.2.1.1.2.BlockEnd:
JUMP TO 2.1.2.2.1.1.WithItem

2.1.2.2.1.FinishClause:
SKIP INSTRUCTION

2.1.2.2.1.2.1.EvaluateClause:
LOAD LITERAL `$innerDone`
STORE VARIABLE $_result_

2.1.2.2.1.2.2.BlockEnd:
SKIP INSTRUCTION

2.1.2.2.2.BlockEnd:
SKIP INSTRUCTION

2.1.2.FinishClause:
SKIP INSTRUCTION

2.1.2.3.1.EvaluateClause:
LOAD LITERAL `$ifDone`
STORE VARIABLE $_result_

2.1.2.3.2.BlockEnd:
SKIP INSTRUCTION

2.1.3.BlockEnd:
JUMP TO 2.1.Outer

2.FinishClause:
SKIP INSTRUCTION

2.2.1.EvaluateClause:
LOAD LITERAL `$outerDone`
STORE VARIABLE $_result_

2.2.2.BlockEnd:
SKIP INSTRUCTION

3.BlockEnd:
SKIP INSTRUCTION


...OK
Testing TestAngle.js..OK
Testing TestBinary.js.OK
Testing TestComplex.js..OK
Testing TestDuration.js.OK
Testing TestMoment.js.OK
Testing TestPercent.js.OK
Testing TestProbability.js.OK
Testing TestReference.js.OK
Testing TestSymbol.js.OK
Testing TestTag.js.OK
Testing TestTemplate.js.OK
Testing TestText.js.OK
Testing TestVersion.js.OK
Testing TestBytecodeUtilities.js..OK
Testing TestEncodingUtilities.js......OK
Testing TestRandomUtilities.js.OK
>> 868 assertions passed (602ms)

Running "concat:dist" (concat) task

Running "uglify:dist" (uglify) task
>> 1 file created 230.84 kB → 80.98 kB

Done.
